1. Create vertex_type datatype as ENUM
```sql
CREATE TYPE vertex_type  
    AS ENUM('player', 'team', 'game')
```

2. Create a table called 'vertices'
```sql
CREATE TABLE vertices (  
    identifier TEXT,  
    type vertex_type,  
    properties JSON, -- postgres doesn't have a map type, so we will use JSON  
    PRIMARY KEY (identifier, type)  
)
```

3. Create edge_type datatype as ENUM
```sql
CREATE TYPE edge_type AS  
    ENUM ('plays_against',  
          'shares_team',  
          'plays_in',  
          'plays_on'  
    )
```

4. Create a table called 'edges'
```sql
CREATE TABLE edges (  
    subject_identifier TEXT,  
    subject_type vertex_type,  
    object_identifier TEXT,  
    object_type vertex_type,  
    edge_type edge_type,  
    properties JSON,  
    PRIMARY KEY (subject_identifier,  
                subject_type,  
                object_identifier,  
                object_type,  
                edge_type)  
)
```

5. Insert game data into vertices table
```sql
INSERT INTO vertices  
SELECT  
    game_id AS identifier,  
    'game'::vertex_type AS TYPE,  
    json_build_object (  
        'pts home', pts_home,  
        'pts_away', pts_away,  
        'winning_team', CASE WHEN home_team_wins = 1 THEN home_team_id ELSE visitor_team_id END  
    ) as properties  
FROM games
```
```csvtable
source: Result_7.csv
```

6. Aggregate data from game_details table to prepare for inserting into vertices table. 
```sql
WITH players_agg AS (  
    SELECT   
player_id AS identifier,  
        MAX(player_name) AS player_name,  
        COUNT(1) AS number_of_games, -- have to aggregate the data from the game_details table  
        SUM(pts) AS total_points,    -- have to aggregate the data from the game_details table  
        ARRAY_AGG(DISTINCT team_id) AS teams
    FROM game_details  
    GROUP BY player_id  
)
```

```csvtable
source: Result_12.csv
```

7. Insert aggregated data from game_details table into vertices table
```sql
INSERT INTO vertices
WITH players_agg AS (  
    SELECT  
        player_id AS identifier,  
        MAX(player_name) AS player_name,  
        COUNT(1) AS number_of_games, -- have to aggregate the data from the game_details table  
        SUM(pts) AS total_points,    -- have to aggregate the data from the game_details table  
        ARRAY_AGG(DISTINCT team_id) AS teams  
    FROM game_details  
    GROUP BY player_id  
)  
SELECT identifier,  
       'player'::vertex_type,  
       json_build_object(  
            'player_name', player_name,  
            'number_of_games',number_of_games,  
            'total_points', total_points,  
            'teams', teams  
       )  
FROM players_agg
```

```csvtable
source: Result_16.csv
```

8. Insert data from teams table into vertices table
```sql
INSERT INTO vertices
SELECT  
   team_id AS identifier,  
    'team'::vertex_type AS type,  
    json_build_object(  
        'abbreviation', abbreviation,  
        'nickname', nickname,  
        'city', city,  
        'arena', arena,  
        'year_founded', yearfounded  
    )  
FROM teams
```

```csvtable
source: Result_19.csv
```
stopped at 27:40

9. Create an edge using data from the game_details table where we have 'plays_against' between two players.  Going to create two edges where we have one on either side via a self-join.  We're going to include a filter on player_name to demonstrate that you basically have duplicate edge cases (that are mirrored).

```sql
select  
    f1.player_id,  
    f2.player_id,  
    f1.player_name,  
    f2.player_name,  
    case  
        when f1.team_abbreviation = f2.team_abbreviation  
            then 'shares_team'::edge_type  
        else 'plays_against'::edge_type  
    end,  
    count(1) as num_games,  
    sum(f1.pts) as left_points,  
    sum(f2.pts) as right_points  
from game_details f1  
join game_details f2  
    on f1.game_id = f2.game_id  
    and f1.player_name <> f2.player_name
where  -- filter for demo purposes only
    f1.player_name in ('Tony Parker', 'Jodie Meeks')   
    and f2.player_name in ('Tony Parker','Jodie Meeks')  
group by  
    f1.player_id,  
    f2.player_id,  
    f1.player_name,  
    f2.player_name,  
    case  
        when f1.team_abbreviation = f2.team_abbreviation  
            then 'shares_team'::edge_type  
        else 'plays_against'::edge_type  
    end;
```

```csvtable
source: and_e_subject_type___v_type.csv
```

In this case it does not matter who the 'subject' and who the 'object' is.

Adding this filter to the where clause will insure we only get one-edge of the edge cases:
```sql
where f1.player_id > f2.player_id
```