![[ClusteredvsNonClusteredIndex.jpg]]

|Feature|**Clustered Index**|**Nonclustered Index**|
|---|---|---|
|**Physical row order**|Yes – the table’s data rows are stored in the order of the index key.|No – data rows are stored separately; index contains pointers to rows.|
|**Data location**|The **leaf nodes of the index contain the actual table data**.|The **leaf nodes contain key values and row locators** (pointers to data).|
|**Number allowed per table**|**One** – because it dictates the physical storage order.|**Many** – you can create multiple indexes for different queries.|
|**Default on**|Usually the **Primary Key** (if not otherwise specified).|Not automatic – created manually for performance tuning.|
|**Best for**|Range queries, sorting, and retrieving large result sets that follow the key order.|Quick lookups on non-key columns, filtering, and covering specific query patterns.|
|**Storage size**|Doesn’t require separate storage for pointers (data is in the index itself).|Requires extra storage for the index plus pointers to the data.|
|**Maintenance**|Updates/inserts/deletes may be slower if they require reordering data.|Less impact on data order, but still needs to be maintained during writes.|
|**Access path**|Direct access to data – no extra lookup.|Usually requires a second lookup to get the full row (unless it’s a **covering index**).|