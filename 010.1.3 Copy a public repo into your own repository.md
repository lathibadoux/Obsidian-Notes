[[#010.1.3.1 Creating a personal copy]]
[[#010.1.3.2 Creating your own fork]]

## 010.1.3.1 Creating a personal copy

Let‚Äôs call the public repo:  
`https://github.com/original-user/public-repo`

and your new repo:  
`https://github.com/your-username/my-repo`



### Step 1: Clone the public repo locally

`git clone https://github.com/original-user/public-repo.git cd public-repo`



### Step 2: Remove the old remote (so your pushes don‚Äôt go to the original)

`git remote remove origin`



### Step 3: Create a **new empty repo** on your GitHub account

- Go to **[https://github.com/new](https://github.com/new)**
    
- Give it a name (e.g., `my-repo`)
    
- ‚ö†Ô∏è **Do not** initialize it with a README, license, or `.gitignore` (keep it empty).
    

You‚Äôll then see a page with your new repo‚Äôs URL, something like:

`https://github.com/your-username/my-repo.git`



### Step 4: Add your new repo as the remote

`git remote add origin https://github.com/your-username/my-repo.git`



### Step 5: Push everything to your new repo

`git branch -M main git push -u origin main`

Now your GitHub account owns the repository ‚Äî no ‚Äúforked from‚Äù label, full control.



### Optional: Clean up history or start fresh

If you don‚Äôt want the commit history of the original repo:

`rm -rf .git git init git add . git commit -m "Initial commit from public repo" git branch -M main git remote add origin https://github.com/your-username/my-repo.git git push -u origin main`

That creates a brand-new repo with only a single initial commit.

---
## 010.1.3.2 Creating your own fork

If you expect the author to keep updating their repo, you‚Äôll probably want a setup where:  
‚úÖ you **own your own copy** (so you can freely modify it),  
‚úÖ **but** you can also **pull in updates** from the original when new lessons drop.

That means the best setup is a **hybrid** of the two approaches ‚Äî _not a fork_, but a ‚Äúmirrored‚Äù repo that tracks the original as a secondary remote.

## üîÑ Recommended Setup: Upstream Remote Pattern

Here‚Äôs how to set that up cleanly:


### Step 1: Clone the public repo

`git clone https://github.com/original-user/tutorial-repo.git cd tutorial-repo`


### Step 2: Rename the original remote

By default, this remote is named `origin`.  
Rename it to `upstream` (so you can use `origin` for your own repo later):

`git remote rename origin upstream`

You can check it worked with:

`git remote -v`

‚úÖ You should see:

`upstream  https://github.com/original-user/tutorial-repo.git (fetch) upstream  https://github.com/original-user/tutorial-repo.git (push)`


### Step 3: Create your own empty repo on GitHub

Go to [https://github.com/new](https://github.com/new),  
name it something like `ai-bootcamp-tutorials` (or whatever fits),  
and **don‚Äôt initialize** with a README or license ‚Äî keep it empty.


### Step 4: Add your own repo as `origin`

`git remote add origin https://github.com/your-username/ai-bootcamp-tutorials.git`

Now check:

`git remote -v`

You should see both:

`origin    https://github.com/your-username/ai-bootcamp-tutorials.git (fetch) upstream  https://github.com/original-user/tutorial-repo.git (fetch)`


### Step 5: Push to your own repo

`git branch -M main git push -u origin main`

Now your repo is live, independent, and still connected to the source.


## üß© When the tutorial author updates their repo

Here‚Äôs how you sync those changes in the future:

1. **Fetch updates from upstream**
    
    `git fetch upstream`
    
2. **Merge them into your local main branch**
    
    `git checkout main git merge upstream/main`
    
    If there are no conflicts, you‚Äôre good to go.  
    If there _are_ conflicts, Git will tell you which files need manual merging.
    
3. **Push your updated main to your GitHub**
    
    `git push origin main`