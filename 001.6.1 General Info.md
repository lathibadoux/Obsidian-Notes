[[#001.6.1.1 What is SQL Partitioning?]]
[[#001.6.1.2 Benefits of SQL Partitioning]]
[[#001.6.1.3 Building Partitions]]
[[#001.6.1.4 Checking the Performance]]

## 001.6.1.1 What is SQL Partitioning?
**SQL Partitioning is a technique to divide a big table into smaller partitions while still being treated as a single table.**

Usually, we are frequently accessing a big table just to interact with the new data.  Rarely do we need the old data.

![[2025-09-08 12_02_22-Add.jpg]]

Divide the table (usually by the date).  The user can see only one table, but behind the scenes you have three tables.  

## 001.6.1.2 Benefits of SQL Partitioning
Benefit #1: Queries will only scan the relevant partition, not the entire table.
![[2025-09-08 12_04_27-find_the_previous_value_of_the_dimension  -  Read-Only - Excel.jpg]]

Benefit #2: The database can process each partition independently and in parallel.  This is called parallel processing.

![[2025-09-08 12_05_50-find_the_previous_value_of_the_dimension  -  Read-Only - Excel.jpg]]

Benefit #3: Partitions make indexing more efficient.  Instead of having one huge index for the whole table, each partition gets it's own index.

![[2025-09-08 12_07_26-find_the_previous_value_of_the_dimension  -  Read-Only - Excel.jpg]]

## 001.6.1.3 Building Partitions

**Overview:**
![[2025-09-08 12_10_02-Add.jpg]]

1. **Define the Partition Function**
	* Define the logic on how to divide into partitions.
	* Based on the partition key (i.e. column, order date, region, etc)
	* Define boundary values
		* Ex. if defining the partition by years, the boundaries would be the last day of the year (for relevant date column)
	* Two methods for identifying which partition the boundary belongs to:
		* Left - Boundary belongs to partition 1
		* Right - Boundary belongs to partition 2
	
![[2025-09-08 12_14_06-Accept the license agreement.jpg]]

* Syntax to create the partition function:
```sql
CREATE PARTITION FUNCTION PartitionByYear (DATE)
AS RANGE LEFT FOR VALUES ('2023-12-31','2024-12-31','2025-12-31','2026-12-31')
```

* Query below will list all existing partition functions.  
```sql
SELECT
	name,
	function_id,
	type,
	type_desc,
	boundary_value_on_right
FROM sys.partition_functions
```

==Always check before creating any new partition functions==

2. **Create Filegroups**
	* A filegroup is a logical container of one or more data files to help organize partitions.
	* Gives freedom and flexibility to decide how the data files are organized for each partition.

![[2025-09-08 12_20_44-User 1 - Anki.jpg]]

* Syntax to create the filegroups:
```sql
ALTER DATABASE SalesDB ADD FILEGROUP FG_2023;
ALTER DATABASE SalesDB ADD FILEGROUP FG_2024;
ALTER DATABASE SalesDB ADD FILEGROUP FG_2025;
ALTER DATABASE SalesDB ADD FILEGROUP FG_2026;
```

* Syntax to delete a filegroup:
```sql
ALTER DATABASE SalesDB REMOVE FILEGROUP FG_2023;
```

* Query to list all existing filegroups:
```sql
SELECT *
FROM sys.filegroups
WHERE type = 'FG'
```

* The ==PRIMARY== filegroup is a default that is created for the database where all objects of the database are stored.

3. **Create Data Files**
	* Data files are going to contain our actual data and will be physically stored in the database.
![[2025-09-08 12_26_25-find_the_previous_value_of_the_dimension  -  Read-Only - Excel.jpg]]

* Add .ndf files to each filegroup:
```sql
ALTER DATABASE SalesDB ADD FILE
(
	NAME = P_2023, -- Logical Name
	FILENAME = 'C:\Program Files\Microsoft SQL Server\MSSQL16.SQLEXPRESS\MSSQL\DATA\P_2023.ndf' -- Path where the file is actually stored.  Will have to ask the DBA's where exactly you can put your partition files.
) TO FILEGROUP FG_2023;
```

* Check the metadata:
```sql
SELECT
	fg.name AS FileGroupName,
	mf.name AS LogicalFileName,
	mf.physical_name AS PhysicalFilePath,
	mf.size / 128 AS SizeInMB
FROM
	sys.filegroup fg
JOIN
	sys.master_files mf ON fg.data_space_id = mf.data_space_id
WHERE
	mf.database_id = DB_ID('SalesDB');
```

Output:
![[2025-09-08 12_34_40-find_the_previous_value_of_the_dimension  -  Read-Only - Excel.jpg]]

4. **Define the partition scheme**
	* Map which partition belongs to which filegroup

![[2025-09-08 12_36_10-find_the_previous_value_of_the_dimension  -  Read-Only - Excel.jpg]]

* Build the partition scheme:
```sql
CREATE PARTITION SCHEME SchemePartitionByYear
AS PARTITION PartitionByYear
TO (FG_2023, FG_2024, FG_2025, FG_2026)
```

==Sort the filegroups according to the result of the function's partitions.==

* Query lists all the partition schemes:
```sql
SELECT
	ps.name AS PartitionSchemeName,
	pf.name AS PartitionFunctionName,
	ds.destination_id AS PartitionNumber,
	fg.name AS Filegroupname
FROM sys.partition_schemes ps
JOIN sys.partition_functions pf ON ps.function_id = pf.function_id
JOIN sys.destination_data_spaces ds ON ps.data_space_id = ds.partition_scheme_id
JOIN sys.filegroups fg ON ds.data_space_id = fg.data_space_id
```

Output:
![[2025-09-08 12_43_15-find_the_previous_value_of_the_dimension  -  Read-Only - Excel.jpg]]

5. **Create the partitioned tables**

```sql
CREATE TABLE Sales.Orders_Partitioned
(
	OrderID INT,
	OrderDate DATE,
	Sales INT
) ON SchemeParitionByYear (OrderDate)
```

Verify that inserted data is going to the correct partition:
```sql
SELECT
	p.partition_number AS PartitionNumber,
	f.name AS PartitionFileGroup,
	p.rows AS NumberOfRows
FROM sys.partitions p
JOIN sys.destination_data_spaces dd ON p.partition_number = dds.destination_id
JOIN sys.filegroups f ON dds.data_space_id = f.data_space_id
WHERE OBJECT_NAME(p.object_id) = 'Orders_Partitioned';
```

==Really important to check whether the boundaries are working correctly==

* You can always use the file explorer to look at the partition information instead of writing queries:
![[2025-09-08 12_49_50-find_the_previous_value_of_the_dimension  -  Read-Only - Excel.jpg]]

## 001.6.1.4 Checking the Performance
==Need to check how the partitions are improving the performance of your query==

1. Need to create a mirrored table without a partition
```sql
SELECT *
INTO Sales.Orders_NoPartition  -- mirrored table
FROM Sales.Orders_Partitioned
```

2. Write a query on both tables and compare the execution plan.  Be sure to activate the execution plan.  The check number of rows that have been read for both queries.
```sql
SELECT *
FROM Sales.Orders_NoPartition
WHERE OrderDate = '2026-01-01'
```

```sql
SELECT *
FROM Sales.Orders_Partitioned
WHERE OrderDate = '2026-01-01'
```

![[2025-09-08 12_57_03-Accept the license agreement.jpg]]
