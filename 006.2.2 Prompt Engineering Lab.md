* FastAPI
	* A way to build a RestAPI
	* In a RestAPI, you have routes.
	* You define functions, and it will return them back to you.
	* Functions:
		* GET - asking for data
		* POST - provide data

* The frontend of the app is the chat.html file (in templates folder) that will give information to the backend (main.py).
* **==user_message==** is the variable that is coming from the frontend.

|Layer|Example|Who Usually Handles It|
|---|---|---|
|Frontend (UI)|`prompt_lab.html`|Web/UI Dev|
|Backend (API)|`main.py`, FastAPI endpoints|AI/Data Engineer|
|Model|`generate_response(prompt)`|AI Engineer|
|Infrastructure|Docker, Render, AWS, etc.|MLOps/Data Engineer|

**Copy the highlighted line for the 'Resume Parser'**

![[linkedinscreenshot.jpg]]

---

![[2025-10-28 12_33_18-Shell Handwriting Canvas.jpg]]

---

- Browser sends `GET /`.
- **Uvicorn** receives the HTTP request (socket/HTTP layer).
- Uvicorn passes it (ASGI event) to **FastAPI**.
- Your handler returns `TemplateResponse` / `HTMLResponse` **to Uvicorn**.
- **Uvicorn** writes the HTTP response back to the **browser**.

---

When a client sends a GET request to `/`, FastAPI calls the `root()` function, gives it a `Request` object containing all request details, and expects `root()` to return a Response.  
In this case, `root()` returns a rendered HTML page (`index.html`) using Jinja2, and passes the `Request` object into the template so it can access request-specific data while rendering.
```python
@app.get("/", response_class=HTMLResponse)
async def root(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})
```

---

Why It Exists:
- **Monitoring:** Used by uptime monitors (like AWS ALB health checks, Azure App Service, Kubernetes probes, or third-party tools like UptimeRobot) to verify that the app is alive.
- **Automation:** Deployment pipelines or CI/CD systems might ping it after a deploy to confirm success.
- **Diagnostics:** Lets developers quickly test whether the server is up without hitting a database or external API.
	```python
	@app.get("/api/health")
	async def health():
	    return {"status": "healthy"}
	```

---

This route is a **backend sanity check**.  
It verifies that:
1. FastAPI is running and reachable at `/api/message`.
2. FastAPI can return **non-JSON** content (in this case, HTML).
3. The frontend (or your browser) can correctly display what the backend sends back.
So it’s your first “Hello, world!” route — confirming the basic request/response loop works.
```python
@app.get("/api/message")
async def get_message():
    """Returns backend message as HTML fragment"""
    return HTMLResponse("<p>Hello World from FastAPI!</p>")
```

---

PubNub is acting as the **real-time transport layer** between:
1. The **backend (FastAPI)** — where you call OpenAI’s API and generate messages, and
2. The **frontend (browser)** — where users watch those messages appear in the chat window.
Think of it as the “live pipe” that carries OpenAI’s responses from the server to the user interface the moment they arrive.
```python
@app.get("/pingpong", response_class=HTMLResponse)
async def pingpong(request: Request):
    """Render the PubNub ping pong page"""
    return templates.TemplateResponse("pingpong.html", {
        "request": request,
        "pubnub_publish_key": pubnub_publish_key,
        "pubnub_subscribe_key": pubnub_subscribe_key
    })
```

---

- `/api/health` → checks if FastAPI is running.
- `/api/data` → checks if Supabase works.
- `/pingpong` → checks if PubNub works.

---
This route takes the user's input (the resume copied from LinkedIn), builds the prompts, sends them to OpenAI, and returns the structured result.
```python
@app.post("/api/parse-resume")
async def parse_resume(request: Request):
    """Parse HTML resume/LinkedIn profile using OpenAI"""
    if not openai_client: # Checks that openai_client exists.  If not returns a JSON error telling you to configure OPENAI_APP_KEY.
        return {
            "error": "OpenAI API key not configured. Please add OPENAI_API_KEY to your .env file."
        }

    try:
        body = await request.json()
        html_content = body.get("html_content", "")

        if not html_content:
            return {"error": "No HTML content provided"}

        # Create a prompt to parse the resume

        system_prompt = """You are a resume parser. Extract and format the key information from HTML content (from LinkedIn profiles or resumes) into only a JSON format.
        Remove any HTML tags, navigation elements, or extraneous information.
Focus on extracting:
```

```javascript
┌───────────────────────────────┐
│         Frontend UI           │
│ (User uploads resume or HTML) │
└──────────────┬────────────────┘
               │  (POST request)
               ▼
┌────────────────────────────────────────┐
│           FastAPI backend              │
│        /api/parse-resume route         │
├────────────────────────────────────────┤
│ 1️⃣ Receives JSON body (or file)       │
│     → request.json()                   │
│     { "html_content": "<html>..." }    │
│                                        │
│ 2️⃣ Builds two messages:               │
│     system_prompt = "You are a parser" │
│     user_prompt   = "Parse this resume"│
│                                        │
│ 3️⃣ Sends to OpenAI                    │
│     openai_client.chat.completions.create(│
│         model="gpt-4o",                │
│         messages=[                     │
│           {"role": "system", "content": system_prompt}, │
│           {"role": "user", "content": user_prompt}      │
│         ],                             │
│         response_format={"type": "json_object"}         │
│     )                                  │
│                                        │
│ 4️⃣ Receives structured response       │
│     {"name": "...", "skills": [...]}   │
│                                        │
│ 5️⃣ (Optional) Saves to DB             │
│     insert_resume(parsed_resume)       │
│                                        │
│ 6️⃣ Returns JSON to frontend           │
│     {"parsed_resume": {...}}           │
└────────────────────────────────────────┘
               │  (HTTP response)
               ▼
┌───────────────────────────────┐
│        Frontend UI            │
│ Displays parsed JSON fields   │
│ ("Name", "Experience", etc.)  │
└───────────────────────────────┘
```



```python
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from supabase import create_client, Client
from pubnub.pnconfiguration import PNConfiguration
from pubnub.pubnub import PubNub
from openai import OpenAI
import os
import json

from dotenv import load_dotenv

load_dotenv()

# Create FastAPI application instance.  Variable represents the web app and all its  routes.  Passed to web server (Uvicorn) to actually serve requests.
app = FastAPI()

# Setup templates
templates = Jinja2Templates(directory="templates")

# Initizalize Supabase client
supabase_url = os.environ.get("SUPABASE_URL")
supabase_key = os.environ.get("SUPABASE_KEY")
supabase: Client = create_client(supabase_url, supabase_key)

# PubNub configuration
pubnub_publish_key = os.environ.get("PUBNUB_PUBLISH_KEY", "demo")
pubnub_subscribe_key = os.environ.get("PUBNUB_SUBSCRIBE_KEY", "demo")  

pnconfig = PNConfiguration() # Create a new configuration object
pnconfig.publish_key = pubnub_publish_key # Attach credentials
pnconfig.subscribe_key = pubnub_subscribe_key # Attach credentials
pnconfig.user_id = "server-instance" # Identify client as "server-instance"

# Initizalize PubNub client
pubnub_client = PubNub(pnconfig) # Create a live connection to PubNub's real-time network

# Initizalize OpenAI client
openai_api_key = os.environ.get("OPENAI_API_KEY")
openai_client = OpenAI(api_key=openai_api_key) if openai_api_key else None 

# Handle GET requests to / using the function root.  That functions renders the html files using the Jinja2 template engine.
@app.get("/", response_class=HTMLResponse) # registers a GET route at / and tells FastAPI to return an HTML response.  
async def root(request: Request): # When someone requests the root (/) URL, call the function named root.  request is a Request object containing all the details about the incoming HTTP request.
    return templates.TemplateResponse("index.html", {"request": request}) # render the index.html file using the Jinja2 templates. Inside the HTML, make the request object available for Jinja to use.

# request is the actual HTTP request your browser sent
# Request is the class that defines what info you can get from it
# : is the type hint - tells Python & FastAPI what to expect
# {"request":request} passes that context into the HTML template

# templates is the Jinja2 template manager
# .TemplateResponse() is the what creates the rendered HTML response
# "index.html" is the HTML file to render
# {"request": request} is the context dictonary which contains the variables to pass to the template.

# Checks if FastAPI is working
@app.get("/api/health")
async def health():
    return {"status": "healthy"}

# Used in projects to verify routing, HTTP responses, and browswer rendering work as expected.
# Checking that the backend can response to the frontend
@app.get("/api/message")
async def get_message():
    """Returns backend message as HTML fragment"""
    return HTMLResponse("<p>Hello World from FastAPI!</p>")

# Checks that Supabase is working
# This route is meant to:
# 1. Fetch data from a Supabase table name "items"
# 2. Render it as HTML snippet (not JSON) so it can be displayed directly on a web page - i.e. the 'data window' on the home page.
# Essentially, it's a mini dashobard route that lets users visually confirm that the backend can successfully read from Supabase.
@app.get("/api/data")
async def get_data():
    """Returns Supabase data as HTML fragment"""
    try:
        # Query 'items' table from Supabase
        response = supabase.table('items').select("*").execute()
        if response.data and len(response.data) > 0:
            data_html = f"<pre>{json.dumps(response.data, indent=2)}</pre>"
        else:
            data_html = "<p>No data from Supabase (make sure to create an 'items' table)</p>"
        return HTMLResponse(data_html)
    except Exception as e:
        return HTMLResponse(f"<p>Error: {str(e)}</p>")

# Ping pong is a diagnostic test page that is built to verify that PubNub's real-time connection works before wiring it into the OpenAI chat
# Checks if PubNub is working
@app.get("/pingpong", response_class=HTMLResponse)
async def pingpong(request: Request):
    """Render the PubNub ping pong page"""
    return templates.TemplateResponse("pingpong.html", {
        "request": request,
        "pubnub_publish_key": pubnub_publish_key,
        "pubnub_subscribe_key": pubnub_subscribe_key
    })

  
  
@app.get("/api/pubnub/config")
async def get_pubnub_config():
    """Returns PubNub configuration"""
    return {
        "publish_key": pubnub_publish_key,
        "subscribe_key": pubnub_subscribe_key
    }


@app.post("/api/pubnub/publish/{channel}")
async def publish_message(channel: str, message: dict):
    """Publish a message to a PubNub channel"""
    try:
        envelope = pubnub_client.publish()\
            .channel(channel)\
            .message(message)\
            .sync()
       return {
            "status": "success",
            "timetoken": envelope.result.timetoken
        }
    except Exception as e:
        return {
            "status": "error",
            "message": str(e)
        }
 

@app.get("/chat", response_class=HTMLResponse)
async def chat_page(request: Request):
    """Render the chat page"""
    return templates.TemplateResponse("chat.html", {"request": request})


@app.post("/api/chat")
async def chat(request: Request):
    """Handle chat messages with OpenAI"""
    if not openai_client:
        return {
            "error": "OpenAI API key not configured. Please add OPENAI_API_KEY to your .env file."
        }
    try:
        body = await request.json()
        user_message = body.get("message", "")
        if not user_message:
            return {"error": "No message provided"}
        # Call OpenAI API
        completion = openai_client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are a senior data engineer who has mastered data engineering. Be very brief"},
                {"role": "user", "content": user_message}
            ],
            max_tokens=50, # Chat can ramble if this is set too high.  Will be a high cost.
            temperature=0
        )
        response_message = completion.choices[0].message.content
        return {"response": response_message}
    except Exception as e:
        return {"error": f"Error communicating with OpenAI: {str(e)}"}


@app.get("/resume", response_class=HTMLResponse)
async def resume_page(request: Request):
    """Render the resume parser page"""
    return templates.TemplateResponse("resume.html", {"request": request})

  
# Accepts a POST request and tries to turn an HTML resume/LinkedIn profile into structured JSON using OpenAI.
@app.post("/api/parse-resume")
async def parse_resume(request: Request):
    """Parse HTML resume/LinkedIn profile using OpenAI"""
    if not openai_client: # Checks that openai_client exists.  If not returns a JSON error telling you to configure OPENAI_APP_KEY.
        return {
            "error": "OpenAI API key not configured. Please add OPENAI_API_KEY to your .env file."
        }

    try: # if try condition is not satisfied, automatically jumps to except block
        body = await request.json()
			# request is a FastAPI Request object - it represents the incoming  HTTP request sent by the client.
			# .json() read the request body and tries to parse it as JSON
			# await means it's an asynchronous operation - FastAPI is async, so it doesn't block other code while waiting for this to finish.

        html_content = body.get("html_content", "")

        if not html_content:
            return {"error": "No HTML content provided"}

        # Create a prompt to parse the resume

        system_prompt = """You are a resume parser. Extract and format the key information from HTML content (from LinkedIn profiles or resumes) into only a JSON format.
        Remove any HTML tags, navigation elements, or extraneous information.
Focus on extracting:
{
"name": "Random Name",
"contact_information": {
"location": "Bay Area"
},
"professional_summary": "Data Engineer @ Meta",
"work_experience": [
{
"company": "Meta",
"title": "Engineer",
"startDate": "May 2025",
"endDate": "Present",
"responsibilities": "I wrote pipelines"
}
],
"education": [
{
"school": "Stanford",
"degree": "Bachelor's Degree, Computer Science",
"startDate": "Not specified",
"endDate": "Not specified"
}
],
"skills": [
"Big Data",
"Machine Learning"
],
"certifications": [
{
"name": "Databricks Certified Professional",
"issue": "Databricks",
"date": "Nov 2015"
}
],
"projects": [
{
"name": "Some Github Repo",
"dates": "Nov 2023 - Present",
"description": "A list of repos or something",
"associated_with": "DataExpert.io"
}
]
}
Format the output as clean JSON"""

        user_prompt = f"Please parse and format this resume into JSON:\n\n{html_content}\n\n"

        # Call OpenAI API
        completion = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0,
            response_format={"type": "json_object"},
            tools=[
                {
                    "type": "function",
                    "function": {
                        "name": "parse_resume",
                        "description": "Parse resume text into a structured schema with work experience, education, skills, certifications, and projects.",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "name": {"type": "string", "description": "Full name of the person"},
                                "contact_information": {
                                    "type": "object",
                                    "properties": {
                                        "location": {"type": "string"}
                                    },
                                    "required": ["location"]
                                },
                                "professional_summary": {"type": "string"},
                                "work_experience": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "company": {"type": "string"},
                                            "title": {"type": "string"},
                                            "startDate": {"type": "string"},
                                            "endDate": {"type": "string"},
                                            "responsibilities": {"type": "string"}
                                        },
                                        "required": ["company", "title"]
                                    }
                                },
                                "education": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "school": {"type": "string"},
                                            "degree": {"type": "string"},
                                            "startDate": {"type": "string"},
                                            "endDate": {"type": "string"}
                                        },
                                        "required": ["school", "degree"]
                                    }
                                },
                                "skills": {
                                    "type": "array",
                                    "items": {"type": "string"}
                                },
                                "certifications": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "name": {"type": "string"},
                                            "issuer": {"type": "string"},
                                            "date": {"type": "string"}
                                        },
                                        "required": ["name", "issuer"]
                                    }
                                },
                                "projects": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "name": {"type": "string"},
                                            "dates": {"type": "string"},
                                            "description": {"type": "string"},
                                            "associated_with": {"type": "string"}
                                        },
                                        "required": ["name"]
                                    }
                                }
                            },
                            "required": ["name", "contact_information", "professional_summary"]
                        }
                    }
                }
            ]
        )
        
        parsed_resume = completion.choices[0].message.content
        insert_resume(json.loads(parsed_resume))

        return {"parsed_resume": parsed_resume}
    except Exception as e:
        return {"error": f"Error parsing resume: {str(e)}"}

  
def insert_resume(resume_json: dict) -> dict:
    """
    Inserts a parsed resume JSON object into the Supabase 'resumes' tab
    Args:
        resume_json (dict): Resume data matching the JSON schema.
    Returns:
        dict: The inserted row data from Supabase.
    """
    # Ensure valid JSON
    if not isinstance(resume_json, dict):
        raise ValueError("resume_json must be a Python dict")

    try:
        response = (
            supabase.table("resumes")
            .insert({"resume": resume_json})
            .execute()
        )

        if response.data:
            print("✅ Resume inserted successfully!")
            return response.data[0]
        else:
            raise Exception(f"Insertion failed: {response}")

    except Exception as e:
        print(f"❌ Error inserting resume: {e}")
        raise
```