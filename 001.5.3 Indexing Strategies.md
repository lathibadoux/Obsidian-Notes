[[#001.5.3.1 Golden Rule]]
[[#001.5.3.2 Phase 1 Initial Indexing Strategy]]
[[#001.5.3.3 Phase 2 Usage Patterns Indexing]]
[[#001.5.3.4 Phase 3 Scenario-Based Indexing]]
[[#001.5.3.4 Phase 4 Monitoring & Maintenance]]
## 001.5.3.1 Golden Rule
**==AVOID OVER INDEXING, LESS IS MORE==**
a. Slow performance. Every time you add data to your table, you have to rearrange the index.  
b. Too many indexes can confuse the execution plan.

## 001.5.3.2 Phase 1: Initial Indexing Strategy
==Identify the main indexing strategy==
* Two basic strategies:
	1. Improve the ==read== performance
	2. Improve the ==write== performance
* In order to define the main goal, you have to understand the system.  Can either have:
	1. OLAP (analytical)
		* Huge queries that will write against a database to generate data warehouses and read against the database to generate reports.  
		* Usually the goal is to improve read performance for OLAP systems.
		* Denormalized fact tables are really large tables that are mostly aggregated.
		* Best strategy is to make the fact tables Columnstore index.

	![[2025-09-05 08_25_58-Screenshots - File Explorer.jpg]]
	
	2. OLTP (transactional)
		* Lots of mini queries for write and read operations coming from an app.  
		* Usually the goal is to improve the write operation.  
		* System is made up of lots of relationships and dimensions.  Very normalized.
		* Usually best strategy is to put a clustered index on all primary keys.
		* Have to be more sensitive adding indexes compared to an OLAP system because indexes may slow read processes.
	
	![[2025-09-05 08_28_17-Screenshots - File Explorer 1.jpg]]
	
	![[2025-09-05 08_30_30-Screenshots - File Explorer.jpg]]
	
## 001.5.3.3 Phase 2: Usage Patterns Indexing

1. Check the queries in your project and identify the most important (frequently used) tables.
2. Check how those tables are being filtered (most important columns) in the queries.

	ChatGPT can help with this:
	![[2025-09-05 08_34_25-Settings.jpg]]

	3. Choose the right index type
	![[2025-09-05 08_36_16-Settings.jpg]]

4. Test the index

	![[2025-09-05 08_40_45-Settings.jpg]]
	
## 001.5.3.4 Phase 3: Scenario-Based Indexing
1. Identify slow queries
2. Analyze queries individually by looking at execution plans
	* Check for full scans of the tables
	* Check for nested loop joins
3. Chose the right index
4. Test (compare) execution plans

![[2025-09-05 08_39_10-Screenshots - File Explorer.jpg]]

## 001.5.3.4 Phase 4: Monitoring & Maintenance
1. Monitor the usage of the indexes
2. Monitor missing indexes.  Check recommendations from database.
3. Monitor duplicate indexes.  Multiple indexes could be created for the same column.
4. Update the statistics.  The database uses that information to decide the best execution plan for the query.
5. Monitor fragmentations.
	*  When to defragment?
		<10 % no action needed
		10 - 30% reorganize index
		> 30% rebuild index
