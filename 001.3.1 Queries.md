[[#001.3.1.1 Fetching Data]]
[[#001.3.1.2 Filtering Data]]
[[#001.3.1.3 Joining Data]]
[[#001.3.1.4 Aggregations]]
[[#001.3.1.5 Subqueries]]

1. For next value or previous value comparisons, use a LAG() or LEAD() window function instead of a self-join with a function on the join predicate.  Example: [[009.1.2.2 197. Rising Temperature]]
2. Golden Rule: Always check the ==execution plan== to confirm performance improvements when optimizing your query.  If there's no improvement, then just focus on ==readability.

## 001.3.1.1 Fetching Data
1. Select only the columns you need.  Don't use SELECT * .
2. Avoid unnecessary DISTINCT and ORDER BY.  These operations take a lot of resources.
3. For exploration purposes, limit the rows.  A good practice is to SELECT TOP # .

## 001.3.1.2 Filtering Data
1. Create non-clustered Index on frequently used columns in WHERE clause.
2. Avoid applying functions to columns in the WHERE clause.  Functions on columns can block index usage.

	**Bad Practice:**
	```sql
	SELECT * FROM Sales.Orders
	WHERE LOWER(OrderStatus) = 'delivered'
```

	**Good Practice:**
	```sql
	SELECT * FROM Sales.Orders
	WHERE OrderStatus = 'Delivered'
```


	**Bad Practice:
	```sql
	SELECT * 
	FROM Sales.Customers
	WHERE SUBSTRING(FirstName, 1, 1) = 'A'
```

	**Good Practice:
	```sql
	SELECT *
	FROM Sales.Customers
	WHERE FirstName LIKE 'A%'
```


	**Bad Practice:
	```sql
	SELECT *
	FROM Sales.Orders
	WHERE YEAR(OrderDate) = 2025
```

	**Good Practice:
	```sql
	SELECT *
	FROM Sales.Orders
	WHERE OrderDate BETWEEN '2025-01-01' AND '2025-12-31'
```

3. Avoid using leading wildcards as they prevent index usage.

	**Bad  Practice:
	```sql
	SELECT *
	FROM Sales.Customers
	WHERE LastName LIKE '%Gold%'
```

	**Good  Practice:
	```sql
	SELECT *
	FROM Sales.Customers
	WHERE LastName LIKE 'Gold%'
```

4. Use IN instead of multiple OR conditions.  OR will kill performance.

	**Bad Practice:
	```sql
	SELECT *
	FROM Sales.Orders
	WHERE CustomerID = 1 OR CustomerID OR CustomerID = 3
```

	**Good Practice:
	```sql
	SELECT *
	FROM Sales.Orders
	WHERE CustomerID IN (1,2,3)
```

## 001.3.1.3 Joining Data
1. Understand the speed of joins & use INNER JOINS when possible.

	**Best Performance:
	```sql
	SELECT c.FirstName
	,o.OrderID
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
		ON c.CustomerID = o.CustomerID
```

	**Slightly Slower Performance:
	```sql
	SELECT c.FirstName
	,o.OrderID
	FROM Sales.Customers c
	RIGHT JOIN Sales.Orders o
		ON c.CustomerID = o.CustomerID
```

```sql
	SELECT c.FirstName
	,o.OrderID
	FROM Sales.Customers c
	LEFT JOIN Sales.Orders o
		ON c.CustomerID = o.CustomerID
```
 
 **Worst Performance:
 ```sql
 SELECT c.FirstName
	,o.OrderID
	FROM Sales.Customers c
	OUTER JOIN Sales.Orders o
		ON c.CustomerID = o.CustomerID
```

2. Use explicit joins (ANSI Join) instead of implicit joins (non-ANSI Joins).  Non-ANSI joins are difficult to read. 

	**Bad Practice:
	```sql
	SELECT o.OrderID, c.FirstName
	FROM Sales.Customers c, Sales.Orders o
	WHERE c.CustomerID = o.CustomerID
```

	**Good Practice:
	```sql
	SELECT o.OrderID, c.FirstName
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
	ON c.CustomerID = o.CustomerID
```

3. Make sure to index the columns used in the ON clause.

4. Filter before joining (Big Tables).  Try to isolate the preparation step in a CTE or subquery.

	**Filter After Join (WHERE):
	```sql
	SELECT c.FirstName, o.OrderID
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
	ON c.CustomerID = o.CustomerID
	WHERE o.OrderStatus = 'Delivered'
```

	**Filter During Join (ON):
	```sql
	SELECT c.FirstName, o.OrderID
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
	ON c.CustomerID = o.CustomerID
	AND o.OrderStatus = 'Delivered'		
	```

	**Filter Before Join (SUBQUERY or CTE):
	```sql
	SELECT c.FirstName, o.OrderID
	FROM Sales.Customers c
	INNER JOIN (
		SELECT OrderID, CustomerID
		FROM Sales.Orders
		WHERE OrderStatus = 'Delivered'
	) o
	ON c.CustomerID = o.CustomerID
	```
	
5. Aggregate before joining (Big Tables)

	**--Best Practice for Small-Medium Tables--
	Grouping and Joining:
	```sql
	SELECT c.CustomerID, c.FirstName, COUNT(o.OrderID) as OrderCount
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
	ON c.CustomerID = o.CustomerID
	GROUP BY c.CustomerID, c.FirstName
```

	**--Best Practice for Big Tables--
	Pre-aggregated Subquery** **(or CTE)**:
	```sql
	SELECT c.CustomerID, c.FirstName, o.OrderCount
	FROM Sales.Customers c
	INNER JOIN (
		SELECT CustomerID, COUNT(OrderID) AS OrderCount
		FROM Sales.Orders
		GROUP BY CustomerID
	) o
	ON c.CustomerID = o.CustomerID
```

	**--Bad Practice--
	Correlated Subquery (worst performance):
	```sql
	SELECT
		c.CustomerID,
		c.FirstName,
		(SELECT COUNT(o.OrderID)
		FROM Sales.Orders o
		WHERE o.CustomerID = c.CustomerID) AS OrderCount
	FROM Sales.Customers c
```
	*Correlated subqueries are really inefficient because SQL executes aggregations for every row.*	

6. Use UNION instead of OR in Joins

	**Bad Practice:
	```sql
	SELECT o.OrderID, c.FirstName
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
	ON c.CustomerID = o.CustomerID
	OR c.CustomerID = o.SalesPersonID
```

	**Best Practice:
	```sql
	SELECT o.OrderID, c.FirstName
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
	ON c.CustomerID = o.CustomerID
	UNION
	SELECT o.OrderID, c.FirstName
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
	ON c.CustomerID = o.SalesPersonID
```

7. Check for nested loops and use SQL HINTS.

	```sql
	SELECT o.OrderID, c.FirstName
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
	ON c.CustomerID = o.CustomerID
```

	**Good Practice for Having Big Table & Small Table:
	```sql
	SELECT o.OrderID, c.FirstName
	FROM Sales.Customers c
	INNER JOIN Sales.Orders o
	ON c.CustomerID = o.CustomerID
	OPTION (HAS JOIN)
```

8. Use UNION ALL instead of using UNION | duplicates ==are== acceptable

	**Bad Practice:
	```sql
	SELECT CustomerID FROM Sales.Orders
	UNION
	SELECT CustomerID FROM Sales.OrdersArchive
```

	**Best Practice:
	```sql
	SELECT CustomerID FROM Sales.Orders
	UNION ALL
	SELECT CustomerID FROM Sales.OrdersArchive
```

9. Use UNION ALL + DISTINCT instead of using UNION | duplicates ==are not== acceptable

	**Bad Practice:
	```sql
	SELECT CustomerID FROM Sales.Orders
	UNION
	SELECT CustomerID FROM Sales.OrdersArchive
	```

	**Best Practice (for big tables):
	```sql
	SELECT DISTINCT CustomerID
	FROM (
		SELECT CustomerID FROM Sales.Orders
		UNION ALL
		SELECT CustomerID FROM Sales.OrdersArchive
	) AS CombinedData
```

## 001.3.1.4 Aggregations

1. Use Columnstore index for aggregations on large tables (example: fact tables).

	```sql
	SELECT CustomerID, COUNT(OrderID) AS OrderCount
	FROM Sales.Orders
	GROUP BY CustomerID

	CREATE CLUSTERED COLUMNSTORE INDEX Idx_Orders_Columnstore ON Sales.Order
```

2. Pre-aggregate data and store it in a new table for reporting.

	```sql
	SELECT MONTH(OrderDate) OrderYear, SUM(Sales) AS TotalSales
	INTO Sales.SalesSummary   -- new table
	FROM Sales.Orders
	GROUP BY MONTH(OrderDate)

	SELECT OrderYear, TotalSales FROM Sales.SalesSummary   -- select new table
```

## 001.3.1.5 Subqueries

1. JOIN vs. EXISTS vs. IN

**JOIN: (Best Practice for small tables):
Use join if performance is not affected.  Easier to write and read than exists.
```sql
SELECT o.OrderID, o.Sales
FROM Sales.Orders o
INNER JOIN Sales.Customers c
ON o.CustomerID = c.CustomerID
WHERE c.Country = 'USA'
```

**EXISTS: (Best Practice for large tables):
EXISTS is better than JOIN because it stops at first match and avoids data duplication.
```sql
SELECT o.OrderID, o.Sales
FROM Sales.Orders o
WHERE EXISTS (
	SELECT 1
	FROM Sales.Customers c
	WHERE c.CustomerID = o.CustomerID
	AND c.Country = 'USA'
)
```

**IN: (Bad Practice):
The IN operator processes and evaluates all rows.  It lacks an early exist mechanism.
```sql
SELECT o.OrderID, o.Sales
FROM Sales.Orders o
WHERE o.CustomerID IN (
	SELECT CustomerID
	FROM Sales.Customers
	WHERE Country = 'USA'
)
```

2. Avoid redundant logic in your queries.  Happens if you have a lot of subqueries

	**Bad Practice:
```sql
SELECT EmployeeID, FirstName, 'Above Average' Status
FROM Sales.Employees
WHERE Salary > (SELECT AVG(Salary)) FROM Sales.Employees)
UNION ALL
SELECT EmployeeID, FirstName, 'Below Average' Status
FROM Sales.Employees
WHERE Salary < (SELECT AVG(Salary)) FROM Sales.Employees)
```
*In this query, the table 'Sales.Employees' is being scanned four times. We also have the same logic twice in the WHERE clause, so that is being calculated twice.*

**Good Practice:
```sql
SELECT
	EmployeeID,
	FirstName,
	CASE
		WHEN Salary > AVG(Salary) OVER () THEN 'Above Average'
		WHEN Salary < AVG(Salary) OVER () THEN 'Below Average'
		ELSE 'Average'
	END AS Status
FROM Sales.Employees
```



