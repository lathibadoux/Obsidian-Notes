## Interview Questions

 **Basic Indexing**
1. **What is an index in a database?**  
    → A data structure that speeds up data retrieval, usually implemented as a B-tree.
    
2. **Why do we use indexes?**  
    → To improve query performance by reducing the amount of data scanned.
    
3. **Difference between clustered and non-clustered index?**  
    → _Clustered_: sorts and stores data rows in index order (only one per table).  
    _Non-clustered_: separate structure with pointers to data.
    
4. **Can a table have more than one clustered index?**  
    → No — the table’s rows can only be physically ordered one way.
    
5. **Advantages & disadvantages of indexes?**  
    → Advantage: faster reads. Disadvantage: slower writes and extra storage.
    
6. **Effect on INSERT/UPDATE/DELETE?**  
    → They slow down because indexes must be updated.
    
7. **Primary key vs. index?**  
    → Primary key enforces uniqueness; index is a performance structure (PK automatically creates an index).
    
8. **Index scan vs. index seek?**  
    → _Seek_: efficient lookup using index keys. _Scan_: reads all index entries.
    
 **Intermediate Indexing**
9. **Covering index?**  
    → An index that contains all needed columns for a query — avoids lookups.
    
10. **Composite index?**  
    → An index on multiple columns; column order matters for filtering.
    
11. **Filtered index?**  
    → Index on a subset of rows; useful for queries with predictable filters.
    
12. **Unique vs. non-unique index?**  
    → Unique enforces no duplicate key values.
    
13. **Fill factor?**  
    → % of space left free in index pages to reduce page splits.
    
14. **Index fragmentation?**  
    → Pages out of order; fixed with REORGANIZE or REBUILD.
    
15. **When to drop an index?**  
    → If it’s unused or hurting write performance.
    
16. **Execution plan usage?**  
    → Look for “Index Seek” or “Index Scan” operators.
    
17. **Heap table vs. clustered table?**  
    → Heap: unordered data pages; clustered: physically ordered rows.
    

---
**Advanced Indexing**
1. **Check if index is used effectively?**  
    → Use execution plans & DMV `sys.dm_db_index_usage_stats`.
    
2. **Index selectivity?**  
    → Ratio of distinct values to total rows; higher selectivity = more efficient.
    
3. **Multiple indexes choice?**  
    → Optimizer picks lowest estimated cost plan.
    
4. **B-tree vs. hash index?**  
    → B-tree: range & exact lookups; hash: fast equality lookups only.
    
5. **Included columns?**  
    → Non-key columns stored in index to make it covering.
    
6. **Indexes & JOINs?**  
    → Matching join keys indexed on both sides improves performance.
    
7. **Indexes & concurrency?**  
    → Can reduce locking but also add contention if overused.
    
8. **Full table scan over index?**  
    → When query returns large % of rows (index overhead not worth it).
    
9. **Temp tables / CTEs?**  
    → Index temp tables explicitly; CTEs don’t persist indexes.
    
10. **Indexed view?**  
    → Materialized view with an index for faster aggregation/lookups.
