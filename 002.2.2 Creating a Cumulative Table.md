1. Create an array object type

```sql
create type season_stats as (  
-- columns you want to include the in array
    season integer,  
    gp integer,  
    pts real,  
    reb real,  
    ast real  
)
```

2. Create a table with the array object as a column

```sql
create table players (  
    player_name text, 
    height text,  
    college text,  
    country text,  
    draft_year text,  
    draft_round text,  
    draft_number text,  
    season_stats season_stats[],  -- array object
    current_season integer,  
    primary key (player_name, current_season)  
)
```

3. Find the first value of the time period you will be incrementing the array on.  In this case, the array will be incremented on season, so we want to find the first current_season.

```sql
select min(current_season)
from players
```

The first season in this example is ==1996==.

4. Write two CTEs, one for the seed year and one for the first current year.  The seed year will be the value before the current year, in this case 1995.  This is the increment that will provide the null values.

```sql
with yesterday as (  
    select * from players  -- selecting the table you will be incrementing the array into
    where current_season = 1995  
),  
    today as (  
        select * from player_seasons  -- selecting the table providing the transactional data
        where season = 1996  
    )
```

5. Now add a select statement to populate the players table with the values from the CTEs

```sql
select  
	-- values in the coalesce statement are all values that will remain consistent across time
    coalesce(t.player_name, y.player_name) as player_name,  
    coalesce(t.height, y.height) as height,  
    coalesce(t.college, y.college) as college,  
    coalesce(t.country, y.country) as country,  
    coalesce(t.draft_year, y.draft_year) as draft_year,  
    coalesce(t.draft_round, y.draft_round) as draft_round,  
    coalesce(t.draft_number, y.draft_number) as draft_number,  
    -- first case statement, when the season_stats array is null (i.e. their first year playing), then just use the values from the player_seasons table.
    case when y.season_stats is NULL  
        then ARRAY[row(  
            t.season,  
            t.gp,  
            t.pts,  
            t.reb,  
            t.ast  
            )::season_stats]  
    -- if the player_season is not null (so the player was active this season, then concatenate the last value in the season_stats column with the new player_seasons values for the current year)
    when t.season is not null then y.season_stats || ARRAY[row(  
            t.season,  
            t.gp,  
            t.pts,  
            t.reb,  
            t.ast  
            )::season_stats]
    -- else, if the player does not have any transactional data for that year, then just use the last value for season_stats in the players table (i.e. the player retired)  
        else y.season_stats  
    end as season_stats,
    coalesce(t.season,y.current_season + 1) as current_season -- If t.season is not null,then return t.season.  If  t.season is null, then return y.current_season + 1.
from today t full outer join yesterday y  -- full outer join today and yesterday on player_name
on t.player_name = y.player_name;
```

5. If you want to blow out the array and get back to the old schema, you can use the code below.

```sql
with unnested as (  
                select player_name,  
                unnest(season_stats) as season_stats  
                from players   
)  
select player_name,  
       (season_stats::season_stats).*  
from unnested
```