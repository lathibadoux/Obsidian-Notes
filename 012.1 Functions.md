[[#012.1.1 Function structure]]
[[#012.1.2 What def means]]
[[#012.1.3 Type hints]]

* A function is defined at the **top level** of your script or module - it's not part of any class or object.
* It is a standalone piece of code
### 012.1.1 Function  structure

* A Python function looks like this:
```python
def function_name(parameters): -> return_type:
    """Optional docstring explaining what it does."""
    # body of the function
    return something
```

| Part              | Meaning                                        |
| ----------------- | ---------------------------------------------- |
| `def`             | Keyword that starts a function definition      |
| `function_name`   | What you’ll call this function later           |
| `(parameters)`    | Input values it can accept                     |
| `:`               | Marks the start of the function body           |
| `return_type`     | Type hint (what type the function will return) |
| `"""Docstring"""` | Optional — explains the function’s purpose     |
| `return`          | Optional — sends a value back to the caller    |

**Example 2 — a function that takes input and returns something**
```python
def add(a, b):
    """Add two numbers together."""
    result = a + b
    return result
```

* Now you can call it:
```python
sum = add(3, 5)
print(sum)
```

**Output:**
```python
8
```

---
### 012.1.2 What def means

* `def` = define a function
* It tells Python:
	* "I'm defining a **function** - a reusable block of code that performs a specific task."

**Example 1 - a simple function**
* This defines a function called `greet`.
```python
def greet():
    print("Hello there!")
```

* To actually *run* it, you call it:
```python
greet()
```

**Output:**
```python
Hello there!
```

---
### 012.1.3 Type hints

* Type hints (also called type annotations) are a way to tell both *humans* and *tools* what kind of data a variable, argument, or return value is supposed to hold.
* They **don't change how Python runs** - Python will still execute your code dynamically - but they make your code easier to **read, debug, and maintain**, and they help tools like **VS Code** of **mypy** catch errors *before* runtime.

**Example:**
```python
def add(a: int, b: int) -> int:
    return a + b
```
That means:
- `a` is expected to be an **int**
- `b` is expected to be an **int**    
- the function will **return an int**

| Type    | Description              | Example                                   |
| ------- | ------------------------ | ----------------------------------------- |
| `int`   | Whole numbers            | `age: int = 30`                           |
| `float` | Decimal numbers          | `price: float = 19.99`                    |
| `str`   | Strings                  | `name: str = "Leigh"`                     |
| `bool`  | True or False            | `is_active: bool = True`                  |
| `list`  | Lists (arrays)           | `scores: list[int] = [90, 85, 88]`        |
| `dict`  | Dictionaries             | `user: dict[str, int] = {"id": 1}`        |
| `tuple` | Tuples (immutable lists) | `point: tuple[float, float] = (3.5, 4.0)` |
| `set`   | Sets (unique values)     | `tags: set[str] = {"python", "sql"}`      |
| `None`  | Indicates “no return”    | `def log(msg: str) -> None:`              |

**More advanced hints**

| Hint                               | Meaning                                 | Example                           |
| ---------------------------------- | --------------------------------------- | --------------------------------- |
| `Optional[type]`                   | Type can be that or `None`              | `Optional[str]` → `str` or `None` |
| `Union[type1, type2]`              | Value can be either type                | `Union[int, float]`               |
| `Any`                              | Can be any type (no restrictions)       | `def f(x: Any) -> Any:`           |
| `Callable[[ArgTypes], ReturnType]` | Function type                           | `Callable[[int, int], int]`       |
| `Iterable[type]`                   | Anything you can loop through           | `Iterable[str]`                   |
| `TypedDict`                        | Dict with fixed keys + value types      | for structured JSON data          |
| `Literal`                          | Value must be one of specific constants | `Literal["small", "large"]`       |
**Type hints go beyond just functions**
* You can add type hints to the following:

| You can add type hints to... | Example                           |
| ---------------------------- | --------------------------------- |
| Function parameters          | `def add(a: int, b: int) -> int:` |
| Function return values       | `-> list[float]`                  |
| Local variables              | `count: int = 0`                  |
| Class attributes             | `title: str`                      |
| Collections                  | `dict[str, float]`, `list[int]`   |
| Optionals                    | `Optional[str] = None`            |
| Dataclasses                  | `@dataclass class Book:`          |
| Constants                    | `API_KEY: str`                    |
