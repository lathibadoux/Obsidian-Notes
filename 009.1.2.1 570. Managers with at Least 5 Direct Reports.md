## ==Question:==
Write a solution to find managers with at least **five direct reports**.

**Input:** 
Employee table:
+-----+-------+------------+-----------+
| id  | name  | department | managerId |
+-----+-------+------------+-----------+
| 101 | John  | A          | null      |
| 102 | Dan   | A          | 101       |
| 103 | James | A          | 101       |
| 104 | Amy   | A          | 101       |
| 105 | Anne  | A          | 101       |
| 106 | Ron   | B          | 101       |
+-----+-------+------------+-----------+
**Output:** 
+------+
| name |
+------+
| John |
+------+

### ==Best Answer==

**IN with Subquery:**
```sql
SELECT name 
FROM Employee 
WHERE id IN (
    SELECT managerId 
    FROM Employee 
    GROUP BY managerId 
    HAVING COUNT(*) >= 5
)
```
* Pros:
  - ✅ Most concise and readable
  - ✅ Subquery executes once (not correlated)
  - ✅ Modern optimizers convert IN to semi-join (similar performance to Query 1)
  - ✅ Clean, idiomatic SQL

  Cons:
  - ⚠️ Doesn't explicitly filter NULLs (though GROUP BY handles it automatically)

  **Execution: Subquery runs once → Semi-join with outer query**

### ==Other Answer==

**JOIN + Derived Table:**
```sql
SELECT e.name
FROM Employee AS e
JOIN (
  SELECT managerId
  FROM Employee
  WHERE managerId IS NOT NULL
  GROUP BY managerId
  HAVING COUNT(*) >= 5
) AS temp
  ON e.id = temp.managerId;

```
 Pros:
  - ✅ Explicit NULL filtering (good practice)
  - ✅ Clear two-step logic: find managers with 5+ reports, then get names
  - ✅ Subquery executes once and materializes results
  - ✅ Easy to read and understand

  Cons:
  - ⚠️ Slightly more verbose than Query 2
  - ⚠️ Creates a derived table (minor overhead)

  **Execution: Full table scan → build temp table → JOIN**

### ==Worst Answer==

**EXISTS with Correlated Subquery:**
```sql
SELECT e.name
FROM Employee e
WHERE EXISTS (
    SELECT 1
    FROM Employee r
    WHERE r.managerId = e.id
    GROUP BY r.managerId
    HAVING COUNT(*) >= 5
);
```
Pros:
  - ✅ EXISTS can short-circuit (stops at first match)

  Cons:
  - ❌ Correlated subquery - runs once per outer row
  - ❌ If you have 1000 employees, this executes 1000 subqueries!
  - ❌ The GROUP BY r.managerId is redundant since WHERE r.managerId = e.id already filters to one manager
  - ❌ Much less efficient with large datasets

  **Execution: For each row in Employee → execute subquery → full table scan of Employee**

